<h1>Static Range</h1>

<pre class="metadata">
Shortname: staticrange
Level:
Group: webplatform
Status: ED
TR: http://www.w3.org/TR/staticrange/
ED: https://github.com/w3c/staticrange/
Repository: garykac/staticrange
Previous Version:
	<none>
Editor: Gary Kacmarcik, Google, garykac@google.com
Abstract:
	This specification defines a lightweight StaticRange that can be used in
	place of a {{Range}} when the complexity of a full {{Range}} is not
	necessary.
	
Status Text:
        This document is an editor's draft proposed as a First Public Working Draft. It has been developed
	in the editing task force of the Web platform working group.
	
</pre>

<h2 id="introduction">Introduction</h2>

	DOM4 defines a {{Range}} object (originally from DOM2 Traversal/Range) which
	can be used to represent a sequence of content in the DOM tree. A {{Range}}
	consists of a start boundary (a node and an offset) and an end boundary
	(also a node and an offset). A key benefit of using a {{Range}} is that once
	it is created, it will maintain the integrity of the range as best it can
	even in the face of DOM mutations.

	A problem with {{Range}} is that whenever a DOM mutation occurs, all of the
	active {{Range}} objects affected by the mutation need to be updated. This
	can be an expensive operation, especially if there are a large number of
	active {{Range}} objects. This cost may be acceptable if all of these
	{{Range}} objects are actually needed by the application, but {{Range}} is
	used whenever we need to record start- and end-positions. Because of this,
	many of the {{Range}} objects that are created are not actually used by the
	application, and many of the {{Range}} objects that are being used donâ€™t
	actually need their range start and end to be resilient to DOM mutations.

	This problem is exacerbated when an application caches an object that
	happens to contain a {{Range}} along with other data that the application
	needs. As long as this object is active, the {{Range}} will be active and it
	will need to be updated for every DOM mutation. In this manner, an
	application can end up with many active {{Range}} objects even if none of
	them are being used.

	A StaticRange is a simple, lightweight range that contains only a start and
	an end boundary (node + offset) and does not update when the DOM is mutated.

<h3 id="interface-staticrange">Interface StaticRange</h3>

	The {{StaticRange}} interface provides attributes that track the start
	and end position of the range, and a readonly boolean attribute that
	indicates whether or not the current range is collapsed to a single
	position (where the start equals the end position).

	To create an instance of the {{StaticRange}} interface, use the
	{{StaticRange}} constructor. The start and end position attributes can
	be set directly, or by using
	{{StaticRange/setStart()}} and {{StaticRange/setEnd()}}.

	<pre class="idl" data-highlight="webidl">
	[Constructor, Exposed=Window]
	interface StaticRange {
		attribute Node startContainer;
		attribute unsigned long startOffset;
		attribute Node endContainer;
		attribute unsigned long endOffset;
		readonly attribute boolean collapsed;

		void setStart(Node node, unsigned long offset);
		void setEnd(Node node, unsigned long offset);

		[NewObject] Range toRange();
	};
	</pre>

	: <dfn for="StaticRange">startContainer</dfn>
	:: The start {{Node}} for the range.

	: <dfn for="StaticRange">startOffset</dfn>
	:: The offset into the start node identifying the [=start position=] for the range.

	: <dfn for="StaticRange">endContainer</dfn>
	:: The end {{Node}} for the range.

	: <dfn for="StaticRange">endOffset</dfn>
	:: The offset into the start node identifying the [=end position=] for the range.

	: <dfn for="StaticRange">collapsed</dfn>
	:: True if the range's [=start position=] and [=end position=] are the same, as determined by
		executing [=update collapsed=].

	: <dfn for="StaticRange">setStart(node, offset)</dfn>
	:: Sets the [=start position=] for this range by executing [=set the start position=]
		with node and offset.

	: <dfn for="StaticRange">setEnd(node, offset)</dfn>
	:: Sets the [=end position=] for this range by executing [=set the end position=]
		with node and offset.

	: <dfn for="StaticRange">toRange()</dfn>
	:: Returns a new {{Range}} with the same start and end as the
		context object.
	:: This is a convenience method to up-convert a StaticRange into a
		full-featured {{Range}} object that can be used when the
		application requires the additional functionality provided by a
		{{Range}}.

	:: It is equivalent to:
		<pre>
			var newRange = document.createRange()
			newRange.selStart(staticRange.startContainer, staticRange.startOffset);
			newRange.selEnd(staticRange.endContainer, staticRange.endOffset);
		</pre>


<h2 id="algorithms">Algorithms</h3>

	A {{StaticRange}} <dfn for="StaticRange">position</dfn> is the combination of a
	{{Node}} <dfn for="StaticRange">position node</dfn> and an unsigned long
	<dfn for="StaticRange">position offset</dfn> into that node. The [=position offset=]
	is the offset from the start of the [=position node=] to the desired position.
	
	The <dfn for="StaticRange">start position</dfn> of a {{StaticRange}} |r| is the
	[=position=] defined by |r|'s [=startContainer=] and [=startOffset=].
	
	The <dfn for="StaticRange">end position</dfn> of a {{StaticRange}} |r| is the
	[=position=] defined by |r|'s [=endContainer=] and [=endOffset=].

	<div class="algorithm" data-algorithm="position-is-less-than">
	<h3 id="to-position-is-less-than">a [=position=] |p1| <dfn for="StaticRange/position">is less than</dfn> another [=position=] |p2|</h3>

		: Input
		:: |p1|, a {{StaticRange}} [=position=]
		:: |p2|, a {{StaticRange}} [=position=]
	
		: Output
		:: Boolean
		
		1. If |p1|'s [=position node=] is earlier in the DOM tree than |p2|'s [=position node=], return True.

		1. If |p1|'s [=position node=] is the same as |p2|'s [=position node=], 
		
			1. If |p1|'s [=position offset=] is less than |p2|'s [=position offset=], return True.
			
			1. Else, return False.
		
		1. Return False.
	</div>

	<div class="algorithm" data-algorithm="position-is-equal-to">
	<h3 id="to-position-is-equal-to">a [=position=] |p1| <dfn for="StaticRange/position">is equal to</dfn> another [=position=] |p2|</h3>

		: Input
		:: |p1|, a {{StaticRange}} [=position=]
		:: |p2|, a {{StaticRange}} [=position=]
	
		: Output
		:: Boolean
		
		1. If |p1|'s [=position node=] is the same as |p2|'s [=position node=], 
		
			1. If |p1|'s [=position offset=] is equal to |p2|'s [=position offset=],

				1. Return True.
					
		1. Return False.
	</div>

	<div class="algorithm" data-algorithm="update-collapsed">
	<h3 id="to-update-collapsed">to <dfn for="StaticRange">update collapsed</dfn></h3>

		: Input
		:: |sr|, a {{StaticRange}} to be updated

		: Output
		:: None

		1. If |sr|'s [=start position=] [=StaticRange/position/is equal to=] |sr|'s [=end position=],
			1. Set |sr|'s [=collapsed=] to True
		1. Else
			1. Set |sr|'s [=collapsed=] to False
	</div>

	<div class="algorithm" data-algorithm="set-the-start-position">
	<h3 id="to-set-the-start-position">to <dfn for="StaticRange">set the start position</dfn></h3>

		: Input
		:: |sr|, a {{StaticRange}} to be updated with a new [=start position=]
		:: |node|, a {{Node}} that contains the [=position node=] of new [=start position=]
		:: |offset|, an unsigned long that identifies the [=position offset=] of the new
			[=start position=]
		
		: Output
		:: None

		1. Let |p| be a [=StaticRange/position=] defined by |node| and |offset|.
		
		1. If |p| [=StaticRange/position/is less than=] or [=StaticRange/position/is equal to=] |sr|'s [=end position=], then
		
			1. Set |sr|'s [=startContainer=] to |node|.
			1. Set |sr|'s [=startOffset=] to |offset|.

		1. Else,

			1. Set |sr|'s [=startContainer=] to [=endContainer=].
			1. Set |sr|'s [=startOffset=] to [=endOffset=].
			1. Set |sr|'s [=endContainer=] to |node|.
			1. Set |sr|'s [=endOffset=] to |offset|.

		2. [=Update collapsed=]
	</div>

	<div class="algorithm" data-algorithm="set-the-end-position">
	<h3 id="to-set-the-end-position">to <dfn for="StaticRange">set the end position</dfn></h3>
				
		: Input
		:: |sr|, a {{StaticRange}} to be updated with a new [=end position=]
		:: |node|, a {{Node}} that contains the [=position node=] of the new [=end position=]
		:: |offset|, an unsigned long that identifies the [=position offset=] of the new
			[=end position=]
		
		: Output
		:: None

		1. Let |p| be a [=StaticRange/position=] defined by |node| and |offset|.

		1. If |p| [=StaticRange/position/is less than=] |sr|'s [=start position=], then

			1. Set |sr|'s [=endContainer=] to [=startContainer=].
			1. Set |sr|'s [=endOffset=] to [=startOffset=].
			1. Set |sr|'s [=startContainer=] to |node|.
			1. Set |sr|'s [=startOffset=] to |offset|.
		
		1. Else,

			1. Set |sr|'s [=endContainer=] to |node|.
			1. Set |sr|'s [=endOffset=] to |offset|.

		2. [=Update collapsed=]
	</div>

<h2 id="acknowledgements-contributors">Acknowledgements</h2>

	Thanks to the following people for the discussions that lead to the creation
	of this proposal:

	Enrica Casucci (Apple),
	Bo Cupp (Microsoft),
	Emil Eklund (Google),
	Gary Kacmarcik (Google),
	Ian Kilpatrick (Google),
	Grisha Lyukshin (Microsoft),
	Miles Maxfield (Apple),
	Ryosuke Niwa (Apple),
	Dave Tapuska (Google),
	Ojan Vafai (Google),
	Johannes Wilm (Fidus)
